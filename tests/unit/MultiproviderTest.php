<?php

declare(strict_types=1);

namespace OpenFeature\Test\unit;

use DateTime;
use Exception;
use InvalidArgumentException;
use Mockery;
use Mockery\MockInterface;
use OpenFeature\Test\TestCase;
use OpenFeature\implementation\flags\EvaluationContext;
use OpenFeature\implementation\multiprovider\Multiprovider;
use OpenFeature\implementation\provider\ResolutionDetailsBuilder;
use OpenFeature\interfaces\provider\ErrorCode;
use OpenFeature\interfaces\provider\Provider;
use OpenFeature\interfaces\provider\ResolutionDetails;
use TypeError;

class MultiproviderTest extends TestCase
{
    /** @var Provider&MockInterface */
    private Provider $mockProvider1;
    /** @var Provider&MockInterface */
    private Provider $mockProvider2;
    /** @var Provider&MockInterface */
    private Provider $mockProvider3;

    protected function setUp(): void
    {
        parent::setUp();
        $this->mockProvider1 = Mockery::mock(Provider::class);
        $this->mockProvider2 = Mockery::mock(Provider::class);
        $this->mockProvider3 = Mockery::mock(Provider::class);

        // Setup basic metadata for providers
        $this->mockProvider1->shouldReceive('getMetadata->getName')->andReturn('Provider1');
        $this->mockProvider2->shouldReceive('getMetadata->getName')->andReturn('Provider2');
        $this->mockProvider3->shouldReceive('getMetadata->getName')->andReturn('Provider3');
    }

    public function testConstructorWithValidProviderData(): void
    {
        $providerData = [
            ['name' => 'test1', 'provider' => $this->mockProvider1],
            ['name' => 'test2', 'provider' => $this->mockProvider2],
        ];

        $multiprovider = new Multiprovider($providerData);
        $this->assertInstanceOf(Multiprovider::class, $multiprovider);
    }

    public function testConstructorWithDuplicateNames(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Duplicate provider names found: test1');

        $providerData = [
            ['name' => 'test1', 'provider' => $this->mockProvider1],
            ['name' => 'test1', 'provider' => $this->mockProvider2],
        ];

        new Multiprovider($providerData);
    }

    public function testConstructorWithEmptyName(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Each provider data entry must have a non-empty string "name" key');

        $providerData = [
            ['name' => '', 'provider' => $this->mockProvider1],
        ];

        new Multiprovider($providerData);
    }

    public function testConstructorWithUnsupportedKeys(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Unsupported keys in provider data entry');

        $providerData = [
            ['name' => 'test1', 'provider' => $this->mockProvider1, 'unsupported' => 'value'],
        ];

        new Multiprovider($providerData);
    }

    public function testAutoGeneratedProviderNames(): void
    {
        $providerData = [
            ['provider' => $this->mockProvider1],
            ['provider' => $this->mockProvider1], // Same provider, should get _2 suffix
        ];

        $multiprovider = new Multiprovider($providerData);
        $this->assertInstanceOf(Multiprovider::class, $multiprovider);
    }

    public function testResolveBooleanValue(): void
    {
        $this->mockProvider1->shouldReceive('resolveBooleanValue')
            ->once()
            ->with('test-flag', false, Mockery::type(EvaluationContext::class))
            ->andReturn($this->createResolutionDetails(true));

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        $result = $multiprovider->resolveBooleanValue('test-flag', false);
        $this->assertTrue($result->getValue());
    }

    public function testResolveStringValue(): void
    {
        $this->mockProvider1->shouldReceive('resolveStringValue')
            ->once()
            ->with('test-flag', 'default', Mockery::type(EvaluationContext::class))
            ->andReturn($this->createResolutionDetails('resolved'));

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        $result = $multiprovider->resolveStringValue('test-flag', 'default');
        $this->assertEquals('resolved', $result->getValue());
    }

    public function testResolveIntegerValue(): void
    {
        $this->mockProvider1->shouldReceive('resolveIntegerValue')
            ->once()
            ->with('test-flag', 0, Mockery::type(EvaluationContext::class))
            ->andReturn($this->createResolutionDetails(42));

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        $result = $multiprovider->resolveIntegerValue('test-flag', 0);
        $this->assertEquals(42, $result->getValue());
    }

    public function testResolveFloatValue(): void
    {
        $this->mockProvider1->shouldReceive('resolveFloatValue')
            ->once()
            ->with('test-flag', 0.0, Mockery::type(EvaluationContext::class))
            ->andReturn($this->createResolutionDetails(3.14));

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        $result = $multiprovider->resolveFloatValue('test-flag', 0.0);
        $this->assertEquals(3.14, $result->getValue());
    }

    public function testResolveObjectValue(): void
    {
        $defaultValue = ['key' => 'default'];
        $resolvedValue = ['key' => 'resolved'];

        $this->mockProvider1->shouldReceive('resolveObjectValue')
            ->once()
            ->with('test-flag', $defaultValue, Mockery::type(EvaluationContext::class))
            ->andReturn($this->createResolutionDetails($resolvedValue));

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        $result = $multiprovider->resolveObjectValue('test-flag', $defaultValue);
        $this->assertEquals($resolvedValue, $result->getValue());
    }

    public function testInvalidDefaultValueType(): void
    {
        $this->expectException(TypeError::class);
        $this->expectExceptionMessage('must be of type bool, string given');

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        // Passing string instead of boolean
        // @phpstan-ignore-next-line intentional wrong type to trigger TypeError
        $multiprovider->resolveBooleanValue('test-flag', 'invalid');
    }

    public function testWithNullEvaluationContext(): void
    {
        $this->mockProvider1->shouldReceive('resolveBooleanValue')
            ->once()
            ->with('test-flag', false, Mockery::type(EvaluationContext::class))
            ->andReturn($this->createResolutionDetails(true));

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        $result = $multiprovider->resolveBooleanValue('test-flag', false, null);
        $this->assertTrue($result->getValue());
    }

    public function testProviderThrowingUnexpectedException(): void
    {
        $this->mockProvider1->shouldReceive('resolveBooleanValue')
            ->once()
            ->andThrow(new Exception('Unexpected error'));

        $providerData = [['name' => 'test1', 'provider' => $this->mockProvider1]];
        $multiprovider = new Multiprovider($providerData);

        $result = $multiprovider->resolveBooleanValue('test-flag', false);

        $this->assertNotNull($result->getError());
        $this->assertEquals(ErrorCode::GENERAL(), $result->getError()->getResolutionErrorCode());
    }

    public function testEmptyProviderList(): void
    {
        $multiprovider = new Multiprovider([]);
        $result = $multiprovider->resolveBooleanValue('test-flag', false);

        $this->assertNotNull($result->getError());
        $this->assertEquals(ErrorCode::GENERAL(), $result->getError()->getResolutionErrorCode());
    }

    /**
     * @param bool|string|int|float|DateTime|array<mixed>|null $value
     */
    private function createResolutionDetails(bool | string | int | float | DateTime | array | null $value): ResolutionDetails
    {
        return (new ResolutionDetailsBuilder())
            ->withValue($value)
            ->build();
    }
}
